# 构造函数

## 构造顺序

``` cpp
// 如继承于基类，构造函数必须先构造基类再构造派生类
class A
{
public:
    A()
    {
        std::cout << "A()" << std::endl;
    }
};

class B : public A
{
public:
    B()
    {
        std::cout << "B()" << std::endl;
    }
};

int main(int argc, char const *argv[])
{
    A a;
    /**
     * => A()
    **/
    B b;
    /**
     * => A()
     * => B()
    **/

    system("pause");
    return 0;
}
```

## 空类中的函数

``` cpp
// 只用在使用它们的时候编译器才会去定义它们
class A
{
public:
    A();                            // 构造函数
    A(const A &);                  // 拷贝构造函数
    ~A();                           // 析构函数
    A & operator=(const A &);       // 赋值运算符
    A * operator&();                // 取址运算符
    const A * operator&() const;    // 取址运算符 const
};
```

## 拷贝构造函数和赋值拷贝构造函数

``` cpp
// 当有新对象生成时，调用的都是拷贝构造函数
// 当没有新对象生成时，调用的都是赋值拷贝构造函数
// 以引用形式则不调用任何一个构造函数
class A
{
public:
    A()
    {
        std::cout << "A()" << std::endl;
    }

    A(const A&)
    {
        std::cout << "A(const A&)" << std::endl;
    }

    A & operator=(const A&)
    {
        std::cout << "operator=(const A&)" << std::endl;
        return *this;
    }
};

void Func1(const A)
{
}

void Func2(const A&)
{
}

int main(int argc, char const *argv[])
{
    A a1;           // A()
    A a2(a1);       // A(const A&)
    A a3 = a1;      // A(const A&)
    a3 = a2;        // operator=(const A&)
    A &a4 = a1;     // 无
    Func1(a1);      // A(const A&)
    Func2(a1);      // 无

    system("pause");
    return 0;
}
```

## 初始化const成员或引用成员

``` cpp
// 初始化顺序为在类中的声明顺序
class A
{
private:
    int m_i;
    const int m_pi;
    int &m_ri;

public:
    A(int i) : m_i(i), m_pi(i), m_ri(i) { }
};
```
